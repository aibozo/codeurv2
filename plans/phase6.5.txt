### Phase 6.5 — **Shared Git-Cache Sidecar**

*A tiny init-/sidecar container that seeds every build pod with a local bare-mirror of the target repository, so subsequent lightweight clones are instantaneous and network-free.*

---

## 1  |  Why it matters

| Problem today                                                                                                | Impact                                                                      |
| ------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------- |
| Every **Coding-Agent**, **Test-Builder**, **CI Runner** does a fresh `git clone --depth=1` over the network. | 100-300 MB traffic per job; high latency when many jobs start concurrently. |
| SSH deploy keys duplicated inside many images.                                                               | Security risk + CI cache invalidation headaches.                            |
| Shallow clones break `git blame` / history lookups.                                                          | Some agents fetch again for full history.                                   |

**Git-Cache sidecar** solves all three:

* All pods that need the repo share the *same bare mirror* on an **`emptyDir`** or **PVC** volume.
* Agents clone locally using `git clone --reference-if-able /cache/repo.git`.
* Only the sidecar holds credentials; job containers are read-only.

---

## 2  |  Container image

`Dockerfile` (`apps/git_cache/Dockerfile`):

```dockerfile
FROM alpine/git:2.44.0
RUN apk add --no-cache openssh-client
WORKDIR /git-cache
# Entrypoint script below
COPY fetch.sh /usr/local/bin/fetch.sh
ENTRYPOINT ["sh","/usr/local/bin/fetch.sh"]
```

`fetch.sh`

```sh
#!/bin/sh
set -e
repo="$REPO_URL"
mirror="/git-cache/$(echo "$repo" | sha1sum | cut -c1-20).git"

if [ ! -d "$mirror" ]; then
  echo "[git-cache] mirroring $repo ..."
  git clone --mirror "$repo" "$mirror"
else
  echo "[git-cache] fetching updates ..."
  git -C "$mirror" remote update --prune
fi
# leave container running so volume stays mounted
tail -f /dev/null
```

*Environment variables required:* `REPO_URL` (SSH or HTTPS remote).

---

## 3  |  Pod template injection (example: Coding-Agent)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: {name: coding-agent}
spec:
  template:
    spec:
      volumes:
        - name: git-cache
          emptyDir: {}          # or PersistentVolumeClaim for cross-node reuse
      initContainers:
        - name: git-cache-init
          image: ghcr.io/your-org/git-cache:latest
          env: [{name: REPO_URL, value: "git@github.com:your-org/repo.git"}]
          volumeMounts: [{name: git-cache, mountPath: /git-cache}]
      containers:
        - name: coding-agent
          image: ghcr.io/your-org/coding-agent:latest
          env:
            - {name: GIT_CACHE_REF, value: /git-cache/$(SHA).git}
          volumeMounts:
            - {name: git-cache, mountPath: /git-cache:ro}
```

*The init-container completes the mirror; the main container clones with:*

```bash
git clone --reference-if-able /git-cache/<hash>.git <WORKDIR>
```

Modify `Coding-Agent` and `Test-Builder` code:

```python
CACHE_REFERENCE = os.getenv("GIT_CACHE_REF")
clone_cmd = ["git","clone","--depth","1"]
if CACHE_REFERENCE and Path(CACHE_REFERENCE).exists():
    clone_cmd += ["--reference-if-able", CACHE_REFERENCE]
clone_cmd += [REMOTE_REPO, str(workdir)]
run(clone_cmd)
```

---

## 4  |  CI Runner update

Runner’s pod template identical: mount the git-cache volume, clone with `--reference-if-able`.

---

## 5  |  Helm/Kustomize snippet (`charts/git-cache/values.yaml`)

```yaml
gitCache:
  image: ghcr.io/your-org/git-cache:latest
  repoUrl: git@github.com:your-org/self-healing-code
  volume:
    type: pvc        # pvc | emptyDir
    size: 5Gi
```

The accompanying `deployment.yaml` renders the init-container automatically for every workload that has label `git-cache.enabled="true"` (via Helm hook or Kustomize patch).

---

## 6  |  Network & Security

* init-container uses **SSH key** via Kubernetes Secret mounted at `/root/.ssh`; main job containers do **not** need any credentials.
* If the volume is a PVC (ReadWriteMany), subsequent pods scheduled on other nodes share the mirror; otherwise `emptyDir` gives per-node cache.
* Optional: run a `git daemon --export-all --base-path=/git-cache` in the sidecar for agents that prefer HTTP fetches.

---

## 7  |  Prometheus metrics

Add in `fetch.sh` (or tiny Python sidecar) to expose:

```text
git_cache_bytes{repo="self-healing-code"} 12345678
git_cache_last_fetch_seconds 1.7
```

Scrape via sidecar port 9901.

---

## 8  |  Unit / Integration tests

`apps/git_cache/tests/test_mirror.py`

```python
import subprocess, tempfile, pathlib, os, shutil
def test_mirror_and_fetch(tmp_path):
    repo = tmp_path/"origin"; repo.mkdir()
    subprocess.run(["git","init","--bare"], cwd=repo, check=True)
    mirror = tmp_path/"mirror.git"
    subprocess.run(["git","clone","--mirror", str(repo), str(mirror)], check=True)
    # add commit to origin then run fetch.sh; validate mirror gets commit
```

---

## 9  |  Commit & Tag

```bash
mkdir -p apps/git_cache apps/git_cache/tests charts/git-cache
git add apps/git_cache charts/git-cache
git commit -m "phase06.5: git-cache sidecar for repo mirror reuse"
git push origin main
git tag phase-06.5-complete
git push origin phase-06.5-complete
```

---

### Phase 6.5 complete

*All job pods now start with a warm local bare-mirror, shrinking clone time from seconds *or minutes* to milliseconds and cutting external bandwidth to near zero. Credentials are centralised, and clone consistency is guaranteed across agents.*
